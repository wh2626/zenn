---
title: 'フロントエンドエンジニアがiOS開発を通して得た学び'
emoji: '🍎'
type: 'tech' # tech: 技術記事 / idea: アイデア
topics: ['swift', 'swiftui', 'frontend', 'mvvm']
published: false
publication_name: 'spacemarket'
---

こんにちは！
スペースマーケットでフロントエンドエンジニアをしているwharaguchiです。

今回の記事は、普段フロントエンドエンジニアとして従事している自分が、iOS開発を行う機会があり、その際にアプリエンジニアからいただいたレビューを自分なりに調査した内容になります。

今回、iOS開発が初めてということもあり、AIを使用してコーディングを行いました。
動作確認とCodexでレビューを行いともに問題がないことを確認してからレビュー依頼をしたのですが、アプリエンジニアからいくつかのレビューを受けました。

レビューで指摘いただいた箇所はたくさんあったのですが、いくつか抜粋したものをご紹介します。

## 今回作成したもの

まだリリース前のものなので詳細はお話できませんが、ユーザー情報を元に特定の画面で表示するモーダルを作成しました。

画面のイメージとしては、Apple Developer Documentationにあるようなモーダルです。

https://developer.apple.com/jp/design/human-interface-guidelines/sheets#iOS-iPadOS

![イメージ図](https://docs-assets.developer.apple.com/published/3ee6d1bdc1e2cf8d19fc0e9a8b8371b7/sheets-large-detent~dark%402x.png)

画面のフローとしては、

1. 画面Aを開いたときにユーザー情報を取得
2. 取得してきた情報に応じて、画面Aにモーダルを表示
3. モーダル内の選択項目を選択すると、モーダルが閉じ再度画面Aに戻る

といったものになります。

## 指摘内容1: ViewModelとViewは必ず1対1の関係にする

上述のとおり、特定の画面にモーダルを表示する実装を行ったため、構造としては親Viewがあり、その中に子Viewとしてモーダルを作成しました。

そこで私は、親View（ParentView）内で親ViewModel（ParentViewModel）をインスタンス化し、子View（ChildView）にenvironmentメソッドで親ViewModelを渡すようにしました。

<!-- 確認ポイント: 以下の例は実際の実装に合わせて直す。ただし該当箇所のみピックアップをする -->

```swift
// ParentView
@State private var viewModel = ParentViewModel()
var Body: some View {
  ChildView().environment(videModel)
}
```

しかし、レビューで以下の指摘をいただきました。

- 子Viewから親ViewのViewModelを直接参照してはいけない（逆も同様）
- 基本的にはViewとViewModelは1対1であるべき

### なぜダメなのか？

私は最初、Reactのpropsのような感覚で、「親が持っているデータを子でも使いたいなら、親のViewModelをそのまま渡せば楽ではないか？」と考えていました。

しかし、iOS（特にMVVMアーキテクチャ）において、これがアンチパターンとされるのには明確な理由がありました。

<!-- 確認ポイント: 以下の例は実際の実装に合わせた理由に直す -->

1. 再利用性が下がる（密結合）
   子Viewが「親のViewModel」という特定の文脈に依存してしまうと、その子Viewを別の画面で使い回すことができなくなります。Viewはあくまで「渡されたデータを表示する」ことに徹するべきです。

2. 責務が曖昧になる
   「どの画面のロジックを誰が管理しているか」が分かりにくくなります。

また今回はテストを書く機会がなかったのですが、ViewとViewModelの依存関係が複雑になると、単体テストを書く際にモックを作るのが大変になる、といったこともあるようです。

### どう直したか

<!-- 確認ポイント: 以下の例は実際の実装に合わせて直す。ただし該当箇所のみピックアップをする -->

「親VMをまるごと渡す」のではなく、「必要な値だけを引数（init）で渡す」形に修正しました。これにより、子Viewは親のことを知る必要がなくなり、設計がきれいになりました。
→どう直したかは改めて確認する

## 指摘内容2: ObservableObjectではなく、@Observableを使用する

AIにコード生成を依頼した際、ViewModelの定義は以下のように出力されました。

<!-- 確認ポイント: 以下の例は実際の実装に合わせた理由に直す -->

```swift
// AIが提案したコード（従来の書き方）
class UserViewModel: ObservableObject {
    @Published var name: String = ""
    @Published var age: Int = 0
}
```

しかし、レビューでは「iOS 17以降を対象としているので、@Observableを使ってください」との指摘がありました。

### 何が違うのか？

調べてみると、これはSwift 5.9（iOS 17）から導入された新しい仕組みでした。

1. 記述がシンプルになる
   従来は変更を検知したい変数すべてに @Published をつける必要がありましたが、新しい書き方ではクラスに @Observable をつけるだけで済みます。

2. パフォーマンスの向上
   従来の ObservableObject は、ViewModel内のプロパティが1つでも変わると、そのViewModelを使っているView全体が再描画されます。
   一方、新しい @Observable は、View側で実際に読み取っているプロパティが変更された時だけ再描画が走ります。

### どう直したか

AIが出力した古いコードを、最新のMacroを使用した記法に書き換えました。

<!-- 確認ポイント: 以下の例は実際の実装に合わせた理由に直す -->

```swift
// 修正後のコード（新しい書き方）
@Observable
class UserViewModel {
    var name: String = ""
    var age: Int = 0
}
```

AIは膨大な過去のコードを学習しておりその中にiOS 17未満の対応のコードも残っているため、「古い書き方」提案してくれたのですが、ここを人間がキャッチアップして補正する必要があるのだと痛感しました。

## さいごに

今回は、FEエンジニアがiOS開発に挑戦した際に受けたレビューの一部を紹介しました。

AIを使えば「とりあえず動くもの」を作ることはできます。
しかし、プロダクトとして長く運用するための「設計」や、OSの進化に合わせた「最新のベストプラクティス」までは、まだAIだけで完結させるのは難しいと感じました。
今後も、ただ動くだけでなく「なぜそう書くのか？」という背景を大切にしながら、iOS開発のキャッチアップを続けていきたいと思います。

最後までお読みいただきありがとうございました！
