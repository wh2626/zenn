---
title: 'フロントエンドエンジニアがiOS開発を通して得た学び'
emoji: '🍎'
type: 'tech' # tech: 技術記事 / idea: アイデア
topics: ['swift', 'swiftui', 'frontend', 'mvvm']
published: false
publication_name: 'spacemarket'
---

こんにちは！
スペースマーケットでフロントエンドエンジニアをしているwharaguchiです。

今回の記事は、普段フロントエンドエンジニアとして従事している自分が、iOS開発を行う機会があり、その際にアプリエンジニアからいただいたレビューを自分なりに調査した内容になります。

今回、iOS開発が初めてということもあり、AIを使用してコーディングを行いました。
動作確認とCodexでレビューを行いともに問題がないことを確認してからレビュー依頼をしたのですが、アプリエンジニアからいくつかのレビューを受けました。

レビューで指摘いただいた箇所はたくさんあったのですが、いくつか抜粋したものをご紹介します。

## 今回作成したもの

まだリリース前のものなので詳細はお話できませんが、ユーザー情報を元に特定の画面で表示するモーダルと、モーダルで行った設定を変更できる設定ページの2つを作成しました。

モーダル画面のイメージとしては、Apple Developer Documentationにあるようなモーダルです。

https://developer.apple.com/jp/design/human-interface-guidelines/sheets#iOS-iPadOS

![イメージ図](https://docs-assets.developer.apple.com/published/3ee6d1bdc1e2cf8d19fc0e9a8b8371b7/sheets-large-detent~dark%402x.png)

画面のフローとしては、

**モーダル**

1. 画面Aを開いたときにユーザー情報を取得
2. 取得してきた情報に応じて、画面Aにモーダルを表示
3. モーダル内の選択項目を選択すると、モーダルが閉じ再度画面Aに戻る

**設定画面**

- モーダルで選択した内容が表示され、選択内容を変更できる

といったものになります。

## 指摘内容1: ViewModelとViewは1対1の関係にする

設定画面の構造としては親Viewがあり、その中に子Viewとして新規設定画面ページを作成しました。

そこで私は、親画面から子画面へViewModelを環境変数（Environment）で渡そうとしました。

```swift
// ParentSettingsScreen.swift
struct ParentSettingsScreen: View {
    @State private var viewModel = ParentSettingsViewModel()

    var body: some View {
        VStack {
            // 子Viewに、親のViewModelをEnvironmentで渡してしまっていた
            ChildSettingView()
                .environment(viewModel)
        }
    }
}
```

```swift
// ChildSettingView.swift
struct ChildSettingView: View {
    var body: some View {
      // 親のViewModelに依存して描画している
      Toggle("設定", isOn: $viewModel.isEnabled)
    }
}
```

しかし、レビューで以下の指摘をいただきました。

- 子Viewから親ViewのViewModelを直接参照してはいけない（逆も同様）
- 基本的にはViewとViewModelは1対1であるべき

### なぜダメなのか？

私は最初、Reactのpropsのような感覚で、「親が持っているデータを子でも使いたいなら、親のViewModelをそのまま渡せば楽ではないか？」と考えていました。

しかし、iOS（特にMVVMアーキテクチャ）において、これがアンチパターンとされるのには明確な理由がありました。

1. 状態管理の責務が混ざる
   子Viewが親ViewModelを直接参照すると、子Viewが自分の状態ではなく親の状態に依存することになります。どの画面の状態を誰が管理しているかが曖昧になり、挙動の追跡が難しくなります。

2. 変更の影響範囲が広がる
   親ViewModelの変更が子Viewの描画や挙動に直接影響するため、修正時に影響範囲の見積もりが難しくなります。

また今回はテストを書く機会がなかったのですが、ViewとViewModelの依存関係が複雑になると、単体テストを書く際にモックを作るのが大変になる、といったこともあるようです。

### どう直したか

最終的には、「ViewModelをEnvironmentで共有する」という構成自体を見直しました。

無理にViewを細かく分割してViewModelを共有しようとするのではなく、「この画面（Screen）が責任を持つべきUIは、この画面のViewModel（1対1）で管理する」形に統合・整理しました。 UIコンポーネントは `private var` や `private func` に切り出すことでコードの見通しを良くしつつ、ViewModelとの1対1の関係を保っています。

```swift
// ParentSettingsScreen.swift（抜粋）
struct ParentSettingsScreen: View {
    @State private var viewModel = ParentSettingsViewModel()

    var body: some View {
        ScrollView(showsIndicators: false) {
            VStack(alignment: .leading) {
                Text(Strings.title)
                ...
            }
        }
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                Button(Strings.save) {
                    viewModel.onSaveButtonTap()
                }
                .disabled(viewModel.isUnselect)
            }
        }
        .onLoad { viewModel.onLoad() }
    }
}
```

## 指摘内容2: ObservableObjectではなく、@Observableを使用する

AIにコード生成を依頼した際、ObservableObjectを使う提案がありましたが、レビューでは「iOS 17以降を対象としているので、@Observableを使ってください」との指摘がありました。現在の実装は以下です。

```swift
// 修正前
@MainActor
final class ParentSettingsViewModel: ObservableObject {
    @Injected(\.thirdPartyConsentRepository)
    private var thirdPartyConsentRepository: any ThirdPartyConsentRepository

    @Published private(set) var selectedStatus: ThirdPartyConsentStatus?
    @Published private(set) var isLoading = false
    @Published private(set) var isSaveFailure = false
    @Published private(set) var isSaveSuccess = false
}
```

### 何が違うのか？

調べてみると、これはSwift5.9（iOS 17）から導入された新しい仕組みでした。

1. パフォーマンスの向上
   従来のObservableObjectは、ViewModel内のプロパティが1つでも変わると、そのViewModelを使っているView全体が再描画されます。
   一方、新しい@Observableは、View側で実際に読み取っているプロパティが変更された時だけ再描画が走ります。

2. 記述がシンプルになる
   従来は変更を検知したい変数すべてに@Publishedをつける必要がありましたが、新しい書き方ではクラスに@Observableをつけるだけで済みます。

### どう直したか

```swift
// 修正後
@MainActor
@Observable
final class ParentSettingsViewModel {
    @ObservationIgnored @Injected(\.thirdPartyConsentRepository)
    private var thirdPartyConsentRepository: any ThirdPartyConsentRepository

    private(set) var selectedStatus: ThirdPartyConsentStatus?
    private(set) var isLoading = false
    private(set) var isSaveFailure = false
    private(set) var isSaveSuccess = false
}
```

ObservableObject+@Publishedの構成をやめ、@Observableを使ったViewModelに置き換えました。さらに、依存注入系のプロパティは@ObservationIgnoredを付けて監視対象から外し、UIが必要な値だけに反応するよう整理しました。

AIは膨大な過去のコードを学習しておりその中にiOS 17未満の対応のコードも残っているため、「古い書き方」提案してくれたのですが、ここを人間がキャッチアップして補正する必要があるのだと痛感しました。

## さいごに

今回は、FEエンジニアがiOS開発に挑戦した際に受けたレビューの一部を紹介しました。

AIを使えば「とりあえず動くもの」を作ることはできます。
しかし、プロダクトとして長く運用するための「設計」や、OSの進化に合わせた「最新のベストプラクティス」までは、まだAIだけで完結させるのは難しいと感じました。
（※自分のAIへの指示にも課題があったと感じています。）

今後も、ただ動くだけでなく「なぜそう書くのか？」という背景を大切にしながら、iOS開発のキャッチアップを続けていきたいと思います。

最後までお読みいただきありがとうございました！
